const express = require("express");
const bcrypt = require("bcryptjs");
const { Op } = require("sequelize");

const { sequelize, User, Voucher, Wallet, Transaction, UserSession } = require("../models");
const { signAccessToken, signRefreshToken, verifyRefreshToken, signAdminToken } = require("../utils/jwt");
const { startSingleSession, enforceSessionFromPayload, revokeSession } = require("../services/sessions");
const { requireAuth } = require("../middleware/auth");

const router = express.Router();

function toPublicUser(user) {
  return {
    id: user.id,
    email: user.email,
    username: user.username,
    role: user.role,
    isActive: user.isActive,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt,
  };
}

function isEphemeralPlayer(user) {
  const email = String(user?.email || "");
  const username = String(user?.username || "");
  return /^\d{6}$/.test(username) && email.endsWith("@playtimeusa.local");
}

function recycleIdentityTag(userId) {
  const short = String(userId || "").replace(/[^a-zA-Z0-9]/g, "").slice(0, 10);
  return `recycled_${Date.now()}_${short}`;
}

async function recyclePlayerCredentials(user, t) {
  const tag = recycleIdentityTag(user.id);
  const newUsername = tag;
  const newEmail = `${tag}@playtimeusa.local`;
  const newPass = await bcrypt.hash(`${tag}:${Math.random()}`, 10);

  user.username = newUsername;
  user.email = newEmail;
  user.passwordHash = newPass;
  user.isActive = false;
  await user.save({ transaction: t });
}

// POST /auth/register
router.post("/register", async (req, res) => {
  try {
    const { email, username, password, role } = req.body;

    if (!email || !username || !password) {
      return res.status(400).json({ error: "email, username, and password are required" });
    }

    const existingEmail = await User.findOne({ where: { email } });
    if (existingEmail) return res.status(409).json({ error: "Email already in use" });

    const existingUsername = await User.findOne({ where: { username } });
    if (existingUsername) return res.status(409).json({ error: "Username already in use" });

    const passwordHash = await bcrypt.hash(password, 10);
    const newUser = await User.create({ email, username, passwordHash, role: role || "player" });

    const session = await startSingleSession({
      actorType: "user",
      userId: newUser.id,
      role: newUser.role,
      ip: req.ip,
      userAgent: req.get("user-agent"),
    });

    const accessToken = signAccessToken(newUser, { actorType: "user", sid: session.id });
    const refreshToken = signRefreshToken(newUser, { actorType: "user", sid: session.id });

    return res.status(201).json({ user: toPublicUser(newUser), tokens: { accessToken, refreshToken }, sessionId: session.id });
  } catch (err) {
    console.error("[AUTH] /auth/register error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

// POST /auth/login (email/username + password)
router.post("/login", async (req, res) => {
  try {
    const { emailOrUsername, password } = req.body;
    if (!emailOrUsername || !password) return res.status(400).json({ error: "emailOrUsername and password are required" });

    const user = await User.findOne({
      where: { [Op.or]: [{ email: emailOrUsername }, { username: emailOrUsername }] },
    });

    if (!user) return res.status(401).json({ error: "Invalid credentials" });
    if (!user.isActive) return res.status(403).json({ error: "Account disabled" });

    const match = await user.checkPassword(password);
    if (!match) return res.status(401).json({ error: "Invalid credentials" });

    const session = await startSingleSession({
      actorType: "user",
      userId: user.id,
      role: user.role,
      ip: req.ip,
      userAgent: req.get("user-agent"),
    });

    const accessToken = signAccessToken(user, { actorType: "user", sid: session.id });
    const refreshToken = signRefreshToken(user, { actorType: "user", sid: session.id });

    return res.json({ user: toPublicUser(user), tokens: { accessToken, refreshToken }, sessionId: session.id });
  } catch (err) {
    console.error("[AUTH] /auth/login error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

/**
 * POST /auth/voucher-login  (public player login)
 * Accepts:
 *   - manual: { userCode, pin }
 *   - QR:     { code, pin }  (optionally also includes userCode)
 *
 * Guarantees single-use with DB transaction + row lock.
 * Creates an ephemeral player user + wallet, credits voucher amount+bonus, marks voucher redeemed.
 */
router.post("/voucher-login", async (req, res) => {
  const { userCode, code, pin } = req.body || {};
  if (!pin || (!userCode && !code)) {
    return res.status(400).json({ error: "pin and (userCode or code) are required" });
  }

  try {
    const result = await sequelize.transaction(async (t) => {
      // Find + lock voucher (single-use)
      let voucher = null;

      if (code) {
        voucher = await Voucher.findOne({
          where: { code, pin, status: "new" },
          transaction: t,
          lock: t.LOCK.UPDATE,
        });
      } else {
        voucher = await Voucher.findOne({
          where: {
            pin,
            status: "new",
            [Op.and]: sequelize.where(
              sequelize.literal(`metadata->>'userCode'`),
              String(userCode)
            ),
          },
          transaction: t,
          lock: t.LOCK.UPDATE,
        });
      }

      if (!voucher) {
        return { ok: false, status: 401, payload: { error: "Invalid code/pin or voucher already used" } };
      }

      if (voucher.expiresAt && new Date(voucher.expiresAt) < new Date()) {
        return { ok: false, status: 400, payload: { error: "Voucher expired" } };
      }

      const meta = voucher.metadata || {};
      const loginCode = String(userCode || meta.userCode || "").trim();

      if (!/^\d{6}$/.test(loginCode)) {
        return { ok: false, status: 500, payload: { error: "Voucher missing valid userCode" } };
      }

      // If a user is still sitting on this username, forcibly recycle it if no active session remains.
      const existing = await User.findOne({
        where: { username: loginCode },
        transaction: t,
        lock: t.LOCK.UPDATE,
      });

      if (existing) {
        const active = await UserSession.findOne({
          where: { userId: existing.id, revokedAt: null },
          transaction: t,
          lock: t.LOCK.UPDATE,
        });

        if (active) {
          return { ok: false, status: 409, payload: { error: "This code is currently in use" } };
        }

        // recycle old record so username becomes available
        await recyclePlayerCredentials(existing, t);
      }

      // Create new ephemeral player
      const passwordHash = await bcrypt.hash(String(pin), 10);
      const email = `${loginCode}@playtimeusa.local`;

      const player = await User.create(
        { email, username: loginCode, passwordHash, role: "player", isActive: true },
        { transaction: t }
      );

      // Wallet + credit
      const currency = voucher.currency || "FUN";
      let wallet = await Wallet.findOne({ where: { userId: player.id, currency }, transaction: t, lock: t.LOCK.UPDATE });
      if (!wallet) {
        wallet = await Wallet.create({ userId: player.id, currency, balance: 0 }, { transaction: t });
      }

      const before = Number(wallet.balance || 0);
      const amount = Number(voucher.amount || 0);
      const bonus = Number(voucher.bonusAmount || 0);
      const total = amount + bonus;

      wallet.balance = before + total;
      await wallet.save({ transaction: t });

      const tx = await Transaction.create(
        {
          walletId: wallet.id,
          type: "voucher_credit",
          amount: total,
          balanceBefore: before,
          balanceAfter: wallet.balance,
          reference: `voucher:${voucher.code}:login`,
          metadata: { voucherId: voucher.id, amount, bonus, userCode: loginCode },
          createdByUserId: player.id,
        },
        { transaction: t }
      );

      // Mark voucher redeemed (single-use)
      voucher.status = "redeemed";
      voucher.redeemedAt = new Date();
      voucher.redeemedByUserId = player.id;
      await voucher.save({ transaction: t });

      return { ok: true, player, wallet, voucher, tx };
    });

    if (!result.ok) {
      return res.status(result.status).json(result.payload);
    }

    // Start session + tokens (outside txn is fine)
    const session = await startSingleSession({
      actorType: "user",
      userId: result.player.id,
      role: "player",
      ip: req.ip,
      userAgent: req.get("user-agent"),
    });

    const accessToken = signAccessToken(result.player, { actorType: "user", sid: session.id });
    const refreshToken = signRefreshToken(result.player, { actorType: "user", sid: session.id });

    const voucherSafe = result.voucher.toJSON ? result.voucher.toJSON() : result.voucher;
    if (voucherSafe && typeof voucherSafe === "object") delete voucherSafe.pin;

    return res.json({
      ok: true,
      user: toPublicUser(result.player),
      tokens: { accessToken, refreshToken },
      sessionId: session.id,
      wallet: result.wallet,
      voucher: voucherSafe,
      transaction: result.tx,
    });
  } catch (err) {
    console.error("[AUTH] /auth/voucher-login error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

// POST /auth/refresh  (session-bound; does NOT reset inactivity timer)
router.post("/refresh", async (req, res) => {
  try {
    const { refreshToken } = req.body;
    if (!refreshToken) return res.status(400).json({ error: "refreshToken is required" });

    const payload = verifyRefreshToken(refreshToken);
    if (payload.type !== "refresh") return res.status(401).json({ error: "Invalid token type" });
    if (payload.actorType !== "user") return res.status(403).json({ error: "Not a user refresh token" });

    await enforceSessionFromPayload(payload, { touch: false });

    const user = await User.findByPk(payload.sub);
    if (!user || !user.isActive) return res.status(401).json({ error: "Invalid or inactive user" });

    const newAccessToken = signAccessToken(user, { actorType: "user", sid: payload.sid });
    const newRefreshToken = signRefreshToken(user, { actorType: "user", sid: payload.sid });

    return res.json({ user: toPublicUser(user), tokens: { accessToken: newAccessToken, refreshToken: newRefreshToken } });
  } catch (err) {
    console.error("[AUTH] /auth/refresh error:", err.message || err);
    return res.status(401).json({ error: "Invalid or expired refresh token" });
  }
});

// POST /auth/logout (revokes session; also destroys ephemeral player credentials)
router.post("/logout", requireAuth, async (req, res) => {
  try {
    await revokeSession(req.user.sid);

    // Destroy credentials for ephemeral players so codes are recyclable.
    if (req.user.actorType === "user" && req.user.role === "player") {
      await sequelize.transaction(async (t) => {
        const u = await User.findByPk(req.user.id, { transaction: t, lock: t.LOCK.UPDATE });
        if (u && isEphemeralPlayer(u)) {
          await recyclePlayerCredentials(u, t);
        }
      });
    }

    return res.json({ ok: true });
  } catch (err) {
    console.error("[AUTH] /auth/logout error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

// POST /admin/login
router.post("/admin/login", async (req, res) => {
  try {
    const { emailOrUsername, password } = req.body;
    if (!emailOrUsername || !password) return res.status(400).json({ error: "emailOrUsername and password are required" });

    const user = await User.findOne({
      where: { [Op.or]: [{ email: emailOrUsername }, { username: emailOrUsername }] },
    });

    if (!user || user.role !== "admin") return res.status(401).json({ error: "Invalid admin credentials" });

    const match = await user.checkPassword(password);
    if (!match) return res.status(401).json({ error: "Invalid admin credentials" });

    const session = await startSingleSession({
      actorType: "user",
      userId: user.id,
      role: user.role,
      ip: req.ip,
      userAgent: req.get("user-agent"),
    });

    const adminToken = signAdminToken(user);
    const accessToken = signAccessToken(user, { actorType: "user", sid: session.id });
    const refreshToken = signRefreshToken(user, { actorType: "user", sid: session.id });

    return res.json({ user: toPublicUser(user), tokens: { adminToken, accessToken, refreshToken }, sessionId: session.id });
  } catch (err) {
    console.error("[AUTH] /admin/login error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

// GET /auth/me
router.get("/me", requireAuth, async (req, res) => {
  try {
    const user = await User.findByPk(req.user.id);
    if (!user) return res.status(404).json({ error: "User not found" });
    return res.json({ user: toPublicUser(user) });
  } catch (err) {
    console.error("[AUTH] /auth/me error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

module.exports = router;
