const express = require("express");
const { sequelize } = require("../models");
const { User, Wallet, Transaction } = require("../models");
const { requireAuth, requireRole, requireSessionHeader } = require("../middleware/auth");

const router = express.Router();

async function getOrCreateWallet(userId, currency, t) {
  const cur = (currency || "FUN").toUpperCase();
  let wallet = await Wallet.findOne({ where: { userId, currency: cur }, transaction: t, lock: t.LOCK.UPDATE });
  if (!wallet) wallet = await Wallet.create({ userId, currency: cur, balance: 0 }, { transaction: t });
  return wallet;
}

// GET /api/v1/wallets (current player)
router.get("/", requireAuth, requireRole("player"), async (req, res) => {
  try {
    const wallets = await Wallet.findAll({ where: { userId: req.user.id } });
    return res.json({ ok: true, wallets });
  } catch (err) {
    console.error("[WALLETS] list self error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
});

// GET /api/v1/wallets/:userId (staff view)
router.get(
  "/:userId",
  requireAuth,
  requireRole("owner", "operator", "admin", "agent", "cashier"),
  async (req, res) => {
    try {
      const { userId } = req.params;
      const wallets = await Wallet.findAll({ where: { userId } });
      if (!wallets || wallets.length === 0) return res.status(404).json({ error: "Wallet not found" });

      const walletIds = wallets.map((w) => w.id);

      const transactions = await Transaction.findAll({
        where: { walletId: walletIds },
        order: [["createdAt", "DESC"]],
        limit: 50,
      });

      return res.json({ wallets, transactions });
    } catch (err) {
      console.error("[WALLETS] GET /wallets/:userId error:", err);
      return res.status(500).json({ error: "Internal server error" });
    }
  }
);

// POST /api/v1/wallets/:userId/credit (staff)
// NOTE: Transaction.type is ENUM; we always write "credit" and store subtype in metadata.
router.post(
  "/:userId/credit",
  requireAuth,
  requireRole("owner", "operator", "admin", "agent", "cashier"),
  requireSessionHeader,
  async (req, res) => {
    const t = await sequelize.transaction();
    try {
      const { userId } = req.params;
      const { amount, currency = "FUN", reference, metadata, subtype } = req.body || {};

      const numericAmount = Number(amount);
      if (!Number.isFinite(numericAmount) || numericAmount <= 0) {
        await t.rollback();
        return res.status(400).json({ error: "amount must be > 0" });
      }

      const user = await User.findByPk(userId, { transaction: t, lock: t.LOCK.UPDATE });
      if (!user) {
        await t.rollback();
        return res.status(404).json({ error: "User not found" });
      }

      const wallet = await getOrCreateWallet(userId, currency, t);

      const balanceBefore = Number(wallet.balance || 0);
      const balanceAfter = balanceBefore + numericAmount;

      wallet.balance = balanceAfter;
      await wallet.save({ transaction: t });

      const tx = await Transaction.create(
        {
          walletId: wallet.id,
          type: "credit",
          amount: numericAmount,
          balanceBefore,
          balanceAfter,
          reference: reference || null,
          metadata: {
            ...(metadata || {}),
            subtype: subtype || "manual_credit",
            sessionId: req.user.sid,
          },
          createdByUserId: req.user.id,
        },
        { transaction: t }
      );

      await t.commit();
      return res.status(201).json({ wallet, transaction: tx });
    } catch (err) {
      console.error("[WALLETS] POST /wallets/:userId/credit error:", err);
      await t.rollback();
      return res.status(500).json({ error: "Internal server error" });
    }
  }
);

// POST /api/v1/wallets/:userId/debit (staff)
// NOTE: Transaction.type is ENUM; we always write "debit" and store subtype in metadata.
router.post(
  "/:userId/debit",
  requireAuth,
  requireRole("owner", "operator", "admin", "agent", "cashier"),
  requireSessionHeader,
  async (req, res) => {
    const t = await sequelize.transaction();
    try {
      const { userId } = req.params;
      const { amount, currency = "FUN", reference, metadata, subtype } = req.body || {};

      const numericAmount = Number(amount);
      if (!Number.isFinite(numericAmount) || numericAmount <= 0) {
        await t.rollback();
        return res.status(400).json({ error: "amount must be > 0" });
      }

      const user = await User.findByPk(userId, { transaction: t, lock: t.LOCK.UPDATE });
      if (!user) {
        await t.rollback();
        return res.status(404).json({ error: "User not found" });
      }

      const wallet = await getOrCreateWallet(userId, currency, t);

      const balanceBefore = Number(wallet.balance || 0);
      if (balanceBefore < numericAmount) {
        await t.rollback();
        return res.status(400).json({ error: "Insufficient funds" });
      }

      const balanceAfter = balanceBefore - numericAmount;

      wallet.balance = balanceAfter;
      await wallet.save({ transaction: t });

      const tx = await Transaction.create(
        {
          walletId: wallet.id,
          type: "debit",
          amount: numericAmount,
          balanceBefore,
          balanceAfter,
          reference: reference || null,
          metadata: {
            ...(metadata || {}),
            subtype: subtype || "manual_debit",
            sessionId: req.user.sid,
          },
          createdByUserId: req.user.id,
        },
        { transaction: t }
      );

      await t.commit();
      return res.status(201).json({ wallet, transaction: tx });
    } catch (err) {
      console.error("[WALLETS] POST /wallets/:userId/debit error:", err);
      await t.rollback();
      return res.status(500).json({ error: "Internal server error" });
    }
  }
);

module.exports = router;
